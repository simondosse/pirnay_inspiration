#%%
from re import U
from turtle import mode
import numpy as np
import NACA
import ROM
import plotter
import matplotlib.pyplot as plt
from input import ModelParameters
from data_manager import save_modal_data

from _functions_AS_optim import map_to_physical

from pymoo.algorithms.soo.nonconvex.de import DE
from pymoo.operators.sampling.lhs import LHS

from pymoo.algorithms.soo.nonconvex.cmaes import CMAES
from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.termination.default import DefaultMultiObjectiveTermination, DefaultSingleObjectiveTermination

from pymoo.optimize import minimize
from ProblemOptim import ProblemOptim
#%%
##########################################################################
coeff_low, coeff_high = 0.7, 1.3  # 70% to 130% of the initial stiffness values (values of the experimental optimal configuration found in Maxime exp at IAT)
para_interval = np.array([
    [0.0, 1.0],                             # u x_ea/c [0.15,0.5]
    [0.0, 1.0],                             # v facteur d'écart du CG à 0.8c
    # the boudaries of x_ea and x_cg are managed in the map_to_physical function

    [350, 500],                         # EIx [Nm²]
    [40, 70]                            # GJ [Nm²]
])

xl = para_interval[:,0]
xu = para_interval[:,1]
n_obj = 1 # nombre d'objectifs à optim en même temps (F)
n_ieq_constr = 0 # nombre de contraintes à respecter (G)

problem_optim_NACA  = ProblemOptim(n_var = para_interval.shape[0], n_obj = n_obj, 
                                    n_ieq_constr = n_ieq_constr, # nombre de contrainted par inéquation
                                    xl=xl, xu=xu, # bornes inf et sup de tous nos paramètres variables
                                    target_mode_idx=1 # the mode on which we'll look for the lowest Uc
)

algorithm_GA = GA(
        pop_size=10,
        sampling=LHS(),
        eliminate_duplicates=True,
        crossover=SBX(prob=0.9, eta=20),
        mutation=PolynomialMutation(prob=1/para_interval.shape[0], eta=20)
        ) 

algorithm_NSGAII=NSGA2( # NSGA hérite de GeneticALgorithm qui hérite de Algorithm
                pop_size=20, #taille de l'échantillon initial
                n_offsprings=10, #taille de chaque échantillon d'enfants créés à partir de la pop actuelle par le biais des opérateurs de croisement et mutation
                                    # un n_offsprings + élevé permet une exploration plus large de l'espace mais prend + de temps
                                    # dans GeneticAlgorithm
                                    # if self.n_offsprings is None:
                                    #      self.n_offsprings = pop_size
                sampling=FloatRandomSampling(), #Méthode d'échantillonage pour la population initiale : échantillonage aléatoire choisi, c'est comme ça par défaut si on renseigne rien 
                crossover=SBX(prob=0.9,eta=20), #Lois de probabilité définissant les opérateurs de croisement (par défait eta=15, prob = 0.9)
                mutation=PolynomialMutation(eta=20), #Lois de probabilité définissant les opérateurs de mutation
                eliminate_duplicates=True, # ce n'est pas un attribut de NSGA2 mais bien de la class dont il hérite GeneticAlgorithm, probablement gérer par le **kwargs
                termination=DefaultMultiObjectiveTermination( # une seule des conditions suivantes entraîne l'arrêt de l'algo
                                xtol=0.0005, # si les changements des paramètres entres gen sont inf à xtol alors on s'arrête. VALEUR de variation MOYENNE ????? ou par PARA ???
                                cvtol=1e-8, # par rapport aux contraintes ?
                                ftol=0.005, # si les changements dans les valeurs des obj entre 2 gen est < a ftol alors on s'arrête
                                n_max_gen=10) # nbr max de gen
                )

algorithm_DE = DE(
    pop_size=20,
    sampling=LHS(),#Méthode d'échantillonage pour la population initiale
    #LHS Latin Hypercub Sampling, couvre uniformement l'espace de var (souvent mieux qu'un echantillon aléatoire ou ça peut être regroupé au même endroit par hasard)
    variant="DE/rand/1/bin", # stratégie de mutation utilisée DE/<base>/<num_diff>/<crossover>
    # rand : vecteur de base x_r est choisi random dans pop
    # 1 : une seule diff (x_a-x_b) utilisée pour construire le mutant v=x_r + F(x_a-x_b)
    # bin : crossover binaire (chq composant du mutant est kept w/ prop CR)
    # autre possibilité : "DE/best/1/bin" : plus exploitant (le meilleur individu comme base → plus rapide, mais risque local minima).
    CR=0.7, #crossover rate: lors du crossover bin chq var du mutant vi remplace celle du parent xi avec prob=CR
    # fonction est très corrélée entre variables, un CR élevé aide
    dither="vector", # modulation du facteur d'amp F
    # dither = None : F constant 0.5
    # dither = 'scalar' : un même F aleatoire est tiré pour toute la pop à chaque génération
    # dither = 'vector : un F diff est tiré pour chq individu -> plus de diversité (meilleur choix pour éviter une convergence prématurée)
    jitter=False # pour perturber F, sur False si dither déjà activé
)

'''CMA-ES tire des individus depuis une loi normale multivariée N(m, sigma²C) dont sigma est la taille de pas globale et C la matrice de covariance'''
algorithm_CMAES = CMAES(
    x0 = np.random.random(problem_optim_NACA.n_var),  # point initial
    sigma = 0.3,  # écart-type initial (taille des pas)
    population_size = None,  # si None, valeur par défaut selon n_var
    sampling = LHS(),  # initialisation de la population
    restarts = 0,  # nombre de redémarrages (utile pour éviter minima locaux)
    restart_from_best = True,  # conserve le meilleur individu au redémarrage
    # tolfun = 1e-6,  # tolérance sur la variation de la fonction objectif
    # tolfunhist = 1e-12,  # tolérance sur l’historique des valeurs f(x)
    # tolx = 1e-12,  # tolérance sur la variation des positions
) #sigma et restarts sont spécifiques à CMAES


algorithms = {
    "GA": algorithm_GA,
    "DE": algorithm_DE,
    "CMAES": algorithm_CMAES
}

termination = DefaultSingleObjectiveTermination(
    ftol=1e-3,   # tolérance sur la variation de F
    period=4,   # nb de générations consécutives à vérifier
    n_max_gen=5  # sécurité : limite dure si jamais ça n'a pas convergé
)

#%%______MINIZATION______________________________________________________________________________

'''
termination = DefaultSingleObjectiveTermination(
    xtol=1e-6,      # tolérance sur les variables
    ftol=1e-6,      # tolérance sur la valeur du meilleur F de la génération, d'une gen à la suivant si ça a pas changé de plus de tol sur n_last gen alors ça stop
    n_last=20,      # nb de générations consécutives à vérifier
    n_max_gen=20,  # borne max
    # n_max_evals=1e5
)
'''



algorithm_name = "GA"  
algorithm = algorithms[algorithm_name]



res = minimize(
                problem_optim_NACA, # herite forcement de la classe Problem et doit présenter une fonction _evaluate() bien définie
                algorithm,       #objet algo optim, il définit le type d'algo d'optim utilisé
                # ('n_gen', 10),       # terminaison : critère d'arrêt pour l'algo, ici on fait n génération et on s'arrête
                termination=termination,
                verbose=True,       # pour afficher ou non les info du processus d'optim, utile pour debug
                seed=2              # permet de reproduire les résultats en fixant la séquence aléatoire
                )                   # save_history(optionnel) sur True l'historique de générations sera enregistré pour un post traitement
'''
res.X : X*
res.F : objective value associated to X F(X)
res.G : same for constraints G(X)
res.CV : violation des contraintes (0 normalement)
res.exec_time : temps de calcul 
'''

np.savez('data/res_'+algorithm_name,resX=res.X, resF = res.F)





#%%_____test optimal solution_______________________________________________________________________
algorithm_name = "GA"
data = np.load('data/res_'+algorithm_name+'.npz')
X_opt = map_to_physical(data['resX'])
s, c = 2.0, 0.2
m = 2.4
eta_w = 0.005
eta_alpha = 0.005
XX = [X_opt[0]*c,X_opt[1]*c,X_opt[2],X_opt[3]]
# x_ea = 0.05
# x_cg = 0.12
# EIx = 447
# GJ = 41
x_ea = XX[0]
x_cg = XX[1]
EIx = XX[2]
GJ = XX[3]
model = ModelParameters(s, c, x_ea=x_ea, x_cg=x_cg, m=m, EIx=EIx, GJ=GJ, eta_w=eta_w, eta_alpha=eta_alpha,model_aero= 'Theodorsen')
model.airfoil.plot_naca00xx_section()

f0, zeta0, eigvals0, eigvecs0, w_modes, alpha_modes, energy_dict = ROM.ModalParamAtRest(model) # normalize = 'per_field' or 'per_mode'
Vq = eigvecs0[:model.Nq, :]

# model.Ustep = 500
# model.Ustep = 15
model.Umax = 30
model.Ustep = 100
f, damping, eigvecs_U, f_modes_U, *_ = ROM.ModalParamDyn(model)
Vq_U = eigvecs_U[:,:model.Nq, :]
# Uc0, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,0], return_status=True)
Uc1, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,1], return_status=True)
Uc2, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,2], return_status=True)
# Uc3, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,3], return_status=True)
# Uc4, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,4], return_status=True)
# Uc5, _ , status = ROM.obj_evaluation(U = model.U, damping = damping[:,5], return_status=True)


plotter.plot_modal_data_single(f,damping,model,suptitle=f'EIx = {EIx}, GJ = {GJ}')
plotter.plot_vi_grid(Vq=Vq, Nw=model.Nw, Nalpha=model.Nalpha, freqs_hz=f0, kind='abs', normalize=None, sharey=True, suptitle='Modal coefficients per mode',mode_indices=(0,1,2))

plotter.plot_vi_grid_over_U(U=model.U,
                            Vq_U=Vq_U,
                            Nw=model.Nw,
                            Nalpha=model.Nalpha,
                            f_modes_U=f_modes_U,
                            normalize = 'l2',
                            mode_indices=(0,1,2))
#%%______________________ test de Uc(x1) pour voir comment on rempli les trous
s, c = 2.0, 0.2
m = 2.4
eta_w = 0.005
eta_alpha = 0.005
EIx = 428
GJ = 48
x_ea = 0.04
x_cg = 0.16
model = ModelParameters(s, c, x_ea=x_ea, x_cg=x_cg, m=m, EIx=EIx, GJ=GJ, eta_w=eta_w, eta_alpha=eta_alpha,model_aero= 'Theodorsen')

x_cg_list = np.linspace(x_ea,0.9*c,35)
x_ea_list = np.linspace(0.01,0.5*c,35)
Uc_map = []
status_list = []
i=1
for x_cg in x_cg_list:
    model.airfoil.x_cg = x_cg
    _, damping, *_ = ROM.ModalParamDyn(model)
    Uc, _ , status= ROM.damping_crossing_slope(U = model.U, damping = damping[:,1],return_status=True)
    Uc_map.append(Uc)
    status_list.append(status)
    
    print(f'{i}/{len(x_cg_list)}')
    i+=1

Uc_map = np.array(Uc_map)
status_list = np.array(status_list)

fig, ax = plt.subplots(figsize=(7, 4))

# Courbe pour relier les points
ax.plot(x_cg_list/c, Uc_map, '-', color='lightgray', linewidth=1.5, zorder=1, label=r'$U_c$ (ligne)')

# Styles par statut
status_style = {
    'cross':       dict(color='tab:green',  marker='o', label='cross'),
    'extrapolated':dict(color='tab:orange', marker='s', label='extrapolated'),
    'censored':    dict(color='tab:red',    marker='X', label='censored'),
}

# Scatter par statut
for key, sty in status_style.items():
    idx = np.where(status_list == key)[0]
    if idx.size == 0:
        continue
    ax.scatter(x_cg_list[idx]/c, Uc_map[idx],
               s=60, marker=sty['marker'], color=sty['color'],
               edgecolors='k', linewidths=0.5, zorder=2, label=sty['label'])

# Style et détails
ax.set_xlabel(r'$x_{cg}/c$', fontsize=12)
ax.set_ylabel(r'$U_c$ [m/s]', fontsize=12)
ax.set_title(r'$U_c(x_{cg})$', fontsize=13, fontweight='bold')
ax.grid(True, which='both', linestyle='--', alpha=0.6)
ax.set_xlim(min(x_cg_list)/c, max(x_cg_list)/c)
ax.tick_params(axis='both', labelsize=10)
ax.legend(title='status', frameon=False)

plt.tight_layout()
plt.show()
# %%_______________________optim on different tracked modes_________________________________________

for i in [1,2,3]: # mode to obj_track : 2,3,4
    
    problem_optim_NACA  = ProblemOptim(n_var = para_interval.shape[0], n_obj = n_obj, 
                                    n_ieq_constr = n_ieq_constr, # nombre de contrainted par inéquation
                                    xl=xl, xu=xu, # bornes inf et sup de tous nos paramètres variables
                                    target_mode_idx=i # the mode on which we'll look for the lowest Uc
    )

    algorithm_name = "GA"
    algorithm = algorithms[algorithm_name]

    termination = DefaultSingleObjectiveTermination(
        ftol=1e-3,   # tolérance sur la variation de F
        period=4,   # nb de générations consécutives à vérifier
        n_max_gen=20  # sécurité : limite dure si jamais ça n'a pas conver
        )
    res = minimize(
                    problem_optim_NACA, # herite forcement de la classe Problem et doit présenter une fonction _evaluate() bien définie
                    algorithm,       #objet algo optim, il définit le type d'algo d'optim utilisé
                    # ('n_gen', 10),       # terminaison : critère d'arrêt pour l'algo, ici on fait n génération et on s'arrête
                    termination=termination,
                    verbose=True,       # pour afficher ou non les info du processus d'optim, utile pour debug
                    seed=2              # permet de reproduire les résultats en fixant la séquence aléatoire
                    )                   # save_history(optionnel) sur True l'historique de générations sera enregistré pour un post traitement
    np.savez('data/res_tracked_mode'+str(i+1)+'_'+algorithm_name,resX=res.X, resF = res.F)

#%%____________________reading results of the diffent optim on diff target mode_____________________________________________________

i=1
algorithm_name = "GA"
data = np.load('data/res_tracked_mode'+str(i+1)+'_'+algorithm_name+'.npz')
X_opt = map_to_physical(data['resX'])
s, c = 2.0, 0.2
m = 2.4
eta_w = 0.005
eta_alpha = 0.005
model = ModelParameters(s, c, x_ea=X_opt[0]*c, x_cg=X_opt[1]*c, m=m, EIx=X_opt[2], GJ=X_opt[3], eta_w=eta_w, eta_alpha=eta_alpha,model_aero= 'Theodorsen')
model.Umax=40
model.airfoil.plot_naca00xx_section()

f, damping, *_ = ROM.ModalParamDyn(model, track_using='fields')
save_modal_data(f = f, damping = damping, model_params=model,out_dir='data', filename=f'model_optim_tracked_mode{i+1}_{algorithm_name}.npz')
plotter.plot_modal_data_single(f,damping,model, suptitle=f'Modal data for optimized model (tracked mode {i+1}, {algorithm_name})')






# %%


'''
EIx_list = [400, 500, 600, 700]
EIx = 280
GJ = 91
GJ_list = [40, 55, 70, 85]


fig, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)
for (i,EIx) in enumerate(EIx_list):

    model.EIx = EIx
    f, damping, *_ = ROM.ModalParamDyn(model, tracked_idx=(0, 1, 2,3))

    if i == 0:
        color = ['lightblue', 'lime', 'lightcoral']
    elif i == len(EIx_list)-1:
        color = ['darkblue', 'darkgreen', 'red']
    else:
        color = ['blue', 'green', 'orange']
    ax[0].plot(f[:, 0], color[0], label=f'EIx = {EIx}')
    ax[0].plot(f[:, 1], color[1])
    ax[0].plot(f[:, 2], color[2])

    ax[1].plot(damping[:, 0], color[0], label=f'EIx = {EIx}')
    ax[1].plot(damping[:, 1], color[1])
    ax[1].plot(damping[:, 2], color[2])

ax[0].set_ylabel('Frequency (Hz)')
ax[0].legend()
ax[1].set_ylabel('Damping ratio')
ax[1].set_xlabel('Wind speed (m/s)')
ax[1].legend()
plt.suptitle(f'GJ = {GJ:.2e}')
plt.show()
'''

# %%
