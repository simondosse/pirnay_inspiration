def plot_mode_shapes_over_U_grid(y,U,WU=None,ALPHAU=None,mode_indices=None,n_samples=10,colors=None,styles=None,sharey=True,figsize=None,suptitle=None,show=True,):
    """
    Plot spatial mode shapes (w and alpha) for multiple wind speeds in a grid.

    Inputs
    ------
    y : array-like, shape (Ny,)
        Spanwise coordinate array.
    U : array-like, shape (nU,)
        Wind speed samples corresponding to WU/ALPHAU.
    WU : array-like or None, shape (nU, n_modes, Ny)
        Bending shapes w_i(y) reconstructed at each U. If None, only alpha is plotted.
    ALPHAU : array-like or None, shape (nU, n_modes, Ny)
        Torsion shapes alpha_i(y) reconstructed at each U. If None, only w is plotted.
    mode_indices : list[int] or None
        Modes to plot. Defaults to all available modes.
        - Accepts 0-based indices (e.g., [0, 1, 2]).
        - Also accepts 1-based indices (e.g., [1, 2, 3]); detection is automatic:
        if all(idx >= 1) and max(idx) <= n_modes, they are treated as 1-based.
    n_samples : int
        Number of U samples to plot, evenly spaced from U[0] to U[-1]. Clipped to len(U).
    colors : dict[str, str] or None
        Colors per field name. Defaults: {'w':'C0', 'alpha':'C1'}.
    styles : dict[str, str] or None
        Line styles per field name. Defaults: {'w':'-', 'alpha':'--'}.
    sharey : bool
        Share Y axis across subplots. Keep False if you already normalized upstream.
    figsize : (float, float) or None
        Figure size. Defaults to (3.0 * n_modes, 2.6 * n_rows), clamped to reasonable minimums.
    suptitle : str or None
        Global figure title.
    show : bool
        If True, calls plt.show().

    Returns
    -------
    fig, axes : matplotlib Figure and Axes array of shape (n_rows, n_cols)

    Notes
    -----
    - WU/ALPHAU are expected as (nU, n_modes, Ny) from your ModalParamDyn.
    - Each subplot overlays w and alpha for a single (mode, U) pair.
    Columns = modes; rows = selected Uâ€™s.
    """
    import numpy as np
    import matplotlib.pyplot as plt

    if WU is None and ALPHAU is None:
        raise ValueError("Provide at least one of WU or ALPHAU.")

    if WU is not None:
        WU = np.asarray(WU)
    if ALPHAU is not None:
        ALPHAU = np.asarray(ALPHAU)

    U = np.asarray(U).ravel()
    y = np.asarray(y).ravel()
    nU = U.size
    Ny = y.size

    # Infer n_modes and validate shapes
    n_modes_candidates = []
    if WU is not None:
        if WU.ndim != 3:
            raise ValueError("WU must have shape (nU, n_modes, Ny).")
        if WU.shape[0] != nU or WU.shape[2] != Ny:
            raise ValueError(f"WU shape mismatch: got {WU.shape}, expected (nU={nU}, n_modes, Ny={Ny}).")
        n_modes_candidates.append(WU.shape[1])
    if ALPHAU is not None:
        if ALPHAU.ndim != 3:
            raise ValueError("ALPHAU must have shape (nU, n_modes, Ny).")
        if ALPHAU.shape[0] != nU or ALPHAU.shape[2] != Ny:
            raise ValueError(f"ALPHAU shape mismatch: got {ALPHAU.shape}, expected (nU={nU}, n_modes, Ny={Ny}).")
        n_modes_candidates.append(ALPHAU.shape[1])

    if not n_modes_candidates:
        raise ValueError("Cannot infer number of modes. Provide WU and/or ALPHAU with valid shapes.")
    n_modes_total = int(min(n_modes_candidates))  # safe choice if shapes differ slightly

    # Select modes
    if mode_indices is None:
        mode_indices_0 = list(range(n_modes_total))
    else:
        idx = np.asarray(mode_indices, dtype=int).ravel().tolist()
        if len(idx) > 0 and min(idx) >= 1 and max(idx) <= n_modes_total:
            mode_indices_0 = [k - 1 for k in idx]  # convert 1-based to 0-based
        else:
            mode_indices_0 = idx
        for k in mode_indices_0:
            if k < 0 or k >= n_modes_total:
                raise ValueError(f"Mode index {k} out of range [0, {n_modes_total-1}].")

    n_cols = len(mode_indices_0)
    if n_cols == 0:
        raise ValueError("No modes selected to plot.")

    # Pick evenly spaced U indices
    n_rows = int(min(max(1, n_samples), nU))
    idx_rows = np.linspace(0, nU - 1, n_rows, dtype=int)
    idx_rows = np.unique(idx_rows)
    n_rows = idx_rows.size

    # Colors / styles defaults
    if colors is None:
        colors = {}
    if styles is None:
        styles = {}
    colors.setdefault('w', 'C0')
    colors.setdefault('alpha', 'C1')
    styles.setdefault('w', '-')
    styles.setdefault('alpha', '--')

    # Figure sizing
    if figsize is None:
        figsize = (max(5.0, 3.0 * n_cols), max(3.0, 1.3 * n_rows))

    fig, axes = plt.subplots(
        n_rows, n_cols,
        sharey=sharey,
        figsize=figsize,
        constrained_layout=True
    )
    if n_rows == 1 and n_cols == 1:
        axes = np.array([[axes]])
    elif n_rows == 1:
        axes = axes.reshape(1, n_cols)
    elif n_cols == 1:
        axes = axes.reshape(n_rows, 1)

    # Plot
    for r, iu in enumerate(idx_rows):
        Uval = float(U[iu])
        for c, kmode in enumerate(mode_indices_0):
